import themes from './themes';
import GamePlay from './GamePlay';
import GameStateService from './GameStateService';
import Swordsman from './characters/Swordsman';
import PositionedCharacter from './PositionedCharacter';
import Bowman from './characters/Bowman';
import Magician from './characters/Magician';
import Daemon from './characters/Daemon';
import Undead from './characters/Undead';
import Vampire from './characters/Vampire';
import { generateTeam, generatePositions } from './generators';
import { formatCharacterInfo, calcMoveRange } from './utils';
import cursors from './cursors';

/**
 * GameController - класс, который отвечает за логику приложения
 * Он создает инстанцию GamePlay и GameStateService,
 * а также добавляет слушателей событий
 * к GamePlay и реагирует на клики/наведение на ячейки
 */

export default class GameController {
  private gamePlay: GamePlay;
  private stateService: GameStateService;
  private playerTeam: PositionedCharacter[];
  private enemyTeam: PositionedCharacter[];
  // Новое свойство
  // Изначально персонаж не выбран (null),
  // а после клика это будет объект PositionedCharacter
  private selectedCharacter: PositionedCharacter | null = null;
  private level: number = 1; // Начальный уровень игры
  private isGameActive: boolean = true;
  private maxScore: number = 0;

  constructor(gamePlay: GamePlay, stateService: GameStateService) {
    console.log('GameController: Constructor called');
    this.gamePlay = gamePlay;
    this.stateService = stateService;
    this.playerTeam = [];
    this.enemyTeam = [];
  }

  init() {
    console.log('GameController: Starting init with theme: prairie');
    // TODO: add event listeners to gamePlay events
    // TODO: добавьте слушателей событий gamePlay
    this.gamePlay.drawUi(themes.prairie);

    // Добавляем слушатели событий
    this.gamePlay.addCellEnterListener((index: number) =>
      this.onCellEnter(index)
    );
    this.gamePlay.addCellLeaveListener((index: number) =>
      this.onCellLeave(index)
    );

    this.gamePlay.addCellClickListener((index: number) =>
      this.onCellClick(index)
    );

    // Добавляем слушатель для New Game
    this.gamePlay.addNewGameListener(() => this.onNewGame());

    // Генерация команд
    const playerTypes = [Swordsman, Bowman, Magician];
    const enemyTypes = [Daemon, Undead, Vampire];
    const playerTeam = generateTeam(playerTypes, 1, 2);
    const enemyTeam = generateTeam(enemyTypes, 1, 2);

    // Позиции для игрока (столбцы 1 и 2: 0, 1, 8, 9, 16, 17, ...),
    const playerPositions = [];
    for (let row = 0; row < 8; row++) {
      playerPositions.push(row * 8, row * 8 + 1);
    }
    console.log(playerPositions);

    // Позиции для врага (столбцы 7 и 8: 6, 7, 14, 15, 22, 23, ...)
    const enemyPositions = [];
    for (let row = 0; row < 8; row++) {
      enemyPositions.push(row * 8 + 6, row * 8 + 7);
    }
    console.log(enemyPositions);

    // Размещение команд
    this.playerTeam = generatePositions(
      playerTeam.getCharacters(),
      playerPositions
    );

    this.enemyTeam = generatePositions(
      enemyTeam.getCharacters(),
      enemyPositions
    );

    // Отрисовка
    this.gamePlay.redrawPositions([...this.playerTeam, ...this.enemyTeam]);
    console.log('GameController: UI drawn');

    // TODO: load saved stated from stateService
    // TODO: загрузить сохраненные данные из stateService

    // загружаем рекорд при старте
    const savedScore = this.stateService.storage.getItem('GameScore');
    if (savedScore) {
      this.maxScore = Number(savedScore);
      console.log('GameController: Загружен рекорд:', this.maxScore);
    }

    // Тест: создаём Swordsman и размещаем на поле
    // const swordsman = new Swordsman(1);
    // const positionedSwordsman = new PositionedCharacter(swordsman, 0); // Позиция 0 (верхний левый угол)
    // this.gamePlay.redrawPositions([positionedSwordsman]); // Рисуем на поле
  }

  private getMoveRange(character: PositionedCharacter): number {
    if (
      character.character instanceof Swordsman ||
      character.character instanceof Undead
    ) {
      return 4;
    }
    if (
      character.character instanceof Bowman ||
      character.character instanceof Vampire
    ) {
      return 2;
    }
    if (
      character.character instanceof Magician ||
      character.character instanceof Daemon
    ) {
      return 1;
    }
    return 0; // На случай неизвестного типа
  }

  private getAttackRange(character: PositionedCharacter): number {
    if (
      character.character instanceof Swordsman ||
      character.character instanceof Undead
    ) {
      return 1;
    }
    if (
      character.character instanceof Bowman ||
      character.character instanceof Vampire
    ) {
      return 2;
    }
    if (
      character.character instanceof Magician ||
      character.character instanceof Daemon
    ) {
      return 4;
    }
    return 0;
  }

  private calcScore(): number {
    // Сумма здоровья всех персонажей игрока
    const healthScore = this.playerTeam.reduce(
      (sum, char) => sum + char.character.health,
      0
    );
    // Умножаем на уровень. Уровень 1 дает x1, Уровень 2 дает x2 и т.д.
    return healthScore * this.level;
  }

  /**
   * ИЗМЕНЕНИЕ: Принимает необязательный финальный счет, чтобы избежать обнуления
   * при Победе (когда команда уже очищена).
   */
  private handleGameOver(finalScore?: number) {
    // 1. Рассчитываем и обновляем максимальный счет
    // Если finalScore передан (для Победы), используем его. Иначе рассчитываем текущий.
    const currentScore = finalScore !== undefined ? finalScore : this.calcScore();

    if (currentScore > this.maxScore) {
      this.maxScore = currentScore;
      GamePlay.showMessage(`Новый рекорд: ${this.maxScore}!`);
    }

    // 2. Сохраняем рекорд в хранилище (GameScore - новый ключ)
    this.stateService.storage.setItem('GameScore', String(this.maxScore));

    // 3. Блокируем игру
    this.isGameActive = false;
    this.gamePlay.blockGame();
    // ИЗМЕНЕНИЕ: Теперь счет будет корректным даже при Победе, где команда очищается раньше.
    GamePlay.showMessage(
      `Игра окончена. Ваш счет: ${currentScore}. Рекорд: ${this.maxScore}.`
    );
  }

  onNewGame() {
    // 1. Сбрасываем все параметры к начальному состоянию
    this.level = 1;
    this.isGameActive = true;
    this.selectedCharacter = null;
    this.playerTeam = [];
    this.enemyTeam = [];

    // 2. Разблокируем поле и снимаем выделение со всех клеток
    this.gamePlay.unblockGame();
    for (let i = 0; i < 64; i++) {
      this.gamePlay.deselectCell(i);
    }

    // 3. Перезапускаем инициализацию, которая создаст новое поле и команды
    // При этом важно НЕ сбрасывать maxScore
    this.init();
  }

  // Метод, который вызывается,
  // когда игрок кликает по ячейке
  async onCellClick(index: number) {
    if (!this.isGameActive) {
      GamePlay.showError('Игра окончена. Нажмите "New Game"');
      return;
    }

    // console.log('GameController: Cell clicked');
    const clickedCharacter = [...this.playerTeam, ...this.enemyTeam].find(
      (p) => p.position === index
    );
    if (clickedCharacter) {
      if (this.playerTeam.includes(clickedCharacter)) {
        // console.log('GameController: Кликнули на персонажа игрока');
        // Если уже выбран другой персонаж - снимаем выделение
        if (this.selectedCharacter) {
          this.gamePlay.deselectCell(this.selectedCharacter.position);
        }
        // Выбираем персонажа
        this.selectedCharacter = clickedCharacter;
        // Выделяем персонажа
        this.gamePlay.selectCell(index);
        // Меняет курсор на pointer
        this.gamePlay.setCursor(cursors.pointer);
      } else if (
        this.selectedCharacter &&
        this.enemyTeam.includes(clickedCharacter)
      ) {
        // Если кликнули на врага и есть выбранный персонаж
        const attackRange = this.getAttackRange(this.selectedCharacter);
        const allowedAttacks = calcMoveRange(
          this.selectedCharacter.position,
          attackRange
        );
        // Доступные клетки для атаки
        if (allowedAttacks.includes(index)) {
          // ИЗМЕНЕНИЕ: Расчет урона, округление и ограничение здоровья
          const calculatedDamage = Math.max(
            this.selectedCharacter.character.getAttack() -
              clickedCharacter.character.getDefence(),
            this.selectedCharacter.character.getAttack() * 0.1
          );
          // Округляем урон до целого числа, минимум 1
          const damage = Math.max(1, Math.round(calculatedDamage));
          
          // Наносим урон
          clickedCharacter.character.health -= damage;
          // Ограничиваем здоровье снизу нулем (для корректной работы)
          clickedCharacter.character.health = Math.max(0, clickedCharacter.character.health);

          // Показываем анимацию урона. Теперь damage уже округлено.
          await this.gamePlay.showDamage(index, damage);
          
          // Если враг мёртв - убираем из команды
          if (clickedCharacter.character.health <= 0) {
            this.enemyTeam = this.enemyTeam.filter(
              (enemy) => enemy !== clickedCharacter
            );
          }
          // Сбрасываем выделение
          if (this.selectedCharacter) {
            this.gamePlay.deselectCell(this.selectedCharacter.position);
          }
          this.gamePlay.deselectCell(index);
          this.selectedCharacter = null; // Снимаем выделение
          this.gamePlay.setCursor(cursors.auto);

          // Перерисовываем поле
          this.gamePlay.redrawPositions([
            ...this.playerTeam,
            ...this.enemyTeam,
          ]);

          // Проверяем победу
          if (this.enemyTeam.length === 0) {
            // Повышаем уровень всех выживших игроков
            for (const player of this.playerTeam) {
              player.character.levelUp();
            }
            // Начинаем новый уровень
            this.startNewLevel();
          } else {
            // Ход противника
            await this.makeEnemyTurn();
          }
        } else {
          // Если враг вне радиуса атаки
          GamePlay.showError('Нельзя атаковать — враг слишком далеко');
        }
      } else {
        // кликнули на врага, но нет выбранного персонажа
        GamePlay.showError('Сначала выберите своего персонажа');
      }
    } else {
      if (this.selectedCharacter) {
        // Если выбран персонаж и кликнули на пустую ячейку
        // Проверяем, можно ли туда пойти

        const moveRange = this.getMoveRange(this.selectedCharacter); // Дальность хода

        const allowedMoves = calcMoveRange(
          this.selectedCharacter.position,
          moveRange
        ); // Доступные клетки

        if (allowedMoves.includes(index)) {
          // Тогда мы перемещаем персонажа
          const oldPosition = this.selectedCharacter.position; // Запоминаем старую позицию
          this.selectedCharacter.position = index; // Обновляем позицию
          this.gamePlay.deselectCell(oldPosition); // Снимаем выделение со старой клетки
          this.gamePlay.deselectCell(index); // Снимаем выделение с новой клетки
          this.selectedCharacter = null; // Сбрасываем выбор
          this.gamePlay.redrawPositions([
            ...this.playerTeam,
            ...this.enemyTeam,
          ]); // Перерисовываем поле
          // Ход противника
          await this.makeEnemyTurn();
        } else {
          // Если нельзя пойти — показываем ошибку
          GamePlay.showError('Сюда пойти нельзя');
        }
      }
    }
  }

  private getPlayerPositions(): number[] {
    const positions: number[] = [];
    for (let row = 0; row < 8; row++) {
      positions.push(row * 8, row * 8 + 1); // Столбцы 1 и 2
    }
    return positions;
  }

  private getEnemyPositions(): number[] {
    const positions: number[] = [];
    for (let row = 0; row < 8; row++) {
      positions.push(row * 8 + 6, row * 8 + 7); // Столбцы 7 и 8
    }
    return positions;
  }

  private startNewLevel(): void {
    this.level += 1;

    let theme: string;
    if (this.level === 1) theme = themes.prairie;
    else if (this.level === 2) theme = themes.desert;
    else if (this.level === 3) theme = themes.arctic;
    else if (this.level === 4) theme = themes.mountain;
    else {
      // ИЗМЕНЕНИЕ: Сначала рассчитываем финальный счет перед очисткой команд
      const finalScore = this.calcScore();

      GamePlay.showMessage('Вы победили! Все уровни пройдены.');
      this.playerTeam = [];
      this.enemyTeam = [];
      this.gamePlay.redrawPositions([]);
      this.handleGameOver(finalScore); // Передаем рассчитанный счет
      return;
    }

    // Отрисовываем новую тему
    this.gamePlay.drawUi(theme);

    // Генерируем НОВЫХ врагов
    const enemyTypes = [Daemon, Undead, Vampire];
    const newEnemyCharacters = generateTeam(
      enemyTypes,
      this.level,
      this.playerTeam.length // Количество врагов равно количеству выживших игроков
    ).getCharacters();
    this.enemyTeam = generatePositions(
      newEnemyCharacters, // <-- Используем только Character[]
      this.getEnemyPositions()
    );

    // Перемещаем ВЫЖИВШИХ игроков на новые позиции,
    // чтобы сохранить их levelUp()
    const playerCharacters = this.playerTeam.map((pc) => pc.character); // Получаем Character[] из PositionedCharacter[]
    this.playerTeam = generatePositions(
      playerCharacters, // <-- Используем персонажей, которые только что получили levelUp
      this.getPlayerPositions()
    );

    // Перерисовываем поле
    this.gamePlay.redrawPositions([...this.playerTeam, ...this.enemyTeam]);

    // Сообщение о новом уровне
    GamePlay.showMessage(`Уровень ${this.level} начат!`);
  }

  onCellEnter(index: number) {
    // TODO: show tooltip
    // TODO: показать tooltip
    const character = [...this.playerTeam, ...this.enemyTeam].find(
      (p) => p.position === index
    );
    if (character) {
      // Показываем тултип с характеристиками
      const level = character.character.getLevel();
      const attack = character.character.getAttack();
      const defence = character.character.getDefence();
      const health = character.character.health;
      const message = formatCharacterInfo`🎖${level} ⚔${attack} 🛡${defence} ❤${health}`;
      this.gamePlay.showCellTooltip(message, index);

      // Если персонаж игрока и можно выбрать его
      if (this.selectedCharacter) {
        const attackRange = this.getAttackRange(this.selectedCharacter);
        const allowedAttacks = calcMoveRange(
          this.selectedCharacter.position,
          attackRange
        );
        if (
          this.enemyTeam.includes(character) &&
          allowedAttacks.includes(index)
        ) {
          this.gamePlay.selectCell(index, 'red');
          this.gamePlay.setCursor(cursors.crosshair);
        } else if (this.playerTeam.includes(character)) {
          this.gamePlay.setCursor(cursors.pointer);
        } else {
          this.gamePlay.setCursor(cursors.notallowed);
        }
      } else {
        if (this.playerTeam.includes(character)) {
          this.gamePlay.setCursor(cursors.pointer);
        } else {
          this.gamePlay.setCursor(cursors.notallowed);
        }
      }
    } else {
      if (this.selectedCharacter) {
        const moveRange = this.getMoveRange(this.selectedCharacter);
        const allowedMoves = calcMoveRange(
          this.selectedCharacter.position,
          moveRange
        );
        if (allowedMoves.includes(index)) {
          this.gamePlay.selectCell(index, 'green');
          this.gamePlay.setCursor(cursors.pointer);
        } else {
          this.gamePlay.setCursor(cursors.notallowed);
        }
      } else {
        this.gamePlay.setCursor(cursors.auto);
      }
    }
  }

  onCellLeave(index: number) {
    // TODO: hide tooltip
    // TODO: убрать tooltip
    this.gamePlay.hideCellTooltip(index);
    if (!this.selectedCharacter || this.selectedCharacter.position !== index) {
      this.gamePlay.deselectCell(index);
    }
    this.gamePlay.setCursor(cursors.auto);
  }

  private async makeEnemyTurn() {
    // Проверяем, есть ли живые враги
    if (this.enemyTeam.length === 0) {
      GamePlay.showMessage('Вы победили!');
      return;
    }

    // Выбираем всех живых соперников
    const aliveEnemies = this.enemyTeam.filter(
      (enemy) => enemy.character.health > 0
    );
    if (aliveEnemies.length === 0) {
      GamePlay.showMessage('Вы победили!');
      return;
    }
    // Выбираем случайного соперника
    const enemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];

    // Проверяем, есть ли игроки в радиусе атаки
    const attackRange = this.getAttackRange(enemy);
    const allowedAttacks = calcMoveRange(enemy.position, attackRange);
    const attackablePlayers = this.playerTeam.filter(
      (player) =>
        allowedAttacks.includes(player.position) && player.character.health > 0
    );
    // Если есть игроки в радиусе атаки
    if (attackablePlayers.length > 0) {
      // Атака: выбираем случайного игрока
      const targetPlayer =
        attackablePlayers[Math.floor(Math.random() * attackablePlayers.length)];
      // Выполняем атаку
      // ИЗМЕНЕНИЕ: Расчет урона, округление и ограничение здоровья
      const calculatedDamage = Math.max(
        enemy.character.getAttack() - targetPlayer.character.getDefence(),
        enemy.character.getAttack() * 0.1
      );
      // Округляем урон до целого числа, минимум 1
      const damage = Math.max(1, Math.round(calculatedDamage));
      
      targetPlayer.character.health -= damage;
      // Ограничиваем здоровье снизу нулем
      targetPlayer.character.health = Math.max(0, targetPlayer.character.health);

      await this.gamePlay.showDamage(targetPlayer.position, damage);
      // Проверяем, жив ли игрок
      if (targetPlayer.character.health <= 0) {
        this.playerTeam = this.playerTeam.filter(
          (player) => player !== targetPlayer
        );
      }
    } else {
      // Перемещение: находим ближайшего игрока

      // Переменная для хранения ссылки на ближайшего игрока
      let nearestPlayer: PositionedCharacter | null = null;

      // переменная для хранения минимальной найденной дистанции
      let minDistance = Infinity;

      for (const player of this.playerTeam) {
        if (player.character.health > 0) {
          // выбирает максимальное из двух значений,
          // что соответствует манхэттенскому расстоянию
          // (движение по клеткам)
          const distance = Math.max(
            Math.abs(
              Math.floor(player.position / 8) - Math.floor(enemy.position / 8)
            ),
            Math.abs((player.position % 8) - (enemy.position % 8))
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearestPlayer = player;
          }
        }
      }

      if (nearestPlayer) {
        // Находим клетки, куда можно пойти
        const moveRange = this.getMoveRange(enemy);
        const allowedMoves = calcMoveRange(enemy.position, moveRange);
        // Фильтруем только свободные клетки
        const freeMoves = allowedMoves.filter((move) => this.isCellFree(move));
        // Фильтруем клетки, которые уменьшают расстояние до игрока
        let bestMove: number | null = null;
        let bestDistance = minDistance;
        for (const move of freeMoves) {
          // Используем freeMoves вместо allowedMoves
          const newDistance = Math.max(
            Math.abs(
              Math.floor(nearestPlayer.position / 8) - Math.floor(move / 8)
            ),
            Math.abs((nearestPlayer.position % 8) - (move % 8))
          );
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            bestMove = move;
          }
        }
        if (bestMove !== null) {
          enemy.position = bestMove;
        }
      }
    }

    // Проверяем, остались ли игроки (после хода AI)
    if (
      this.playerTeam.length === 0 ||
      this.playerTeam.every((player) => player.character.health <= 0)
    ) {
      // Перерисовываем поле перед сообщением (чтобы игрок увидел смерть)
      this.gamePlay.redrawPositions([...this.playerTeam, ...this.enemyTeam]);
      // При поражении calcScore() вернет 0, так как здоровье = 0.
      this.handleGameOver(); // Вызываем метод завершения игры
      return;
    }

    // Перерисовываем поле (если не было поражения)
    this.gamePlay.redrawPositions([...this.playerTeam, ...this.enemyTeam]);
  }

  // метод для проверки свободной клетки
  private isCellFree(index: number): boolean {
    // Проверяем, нет ли на клетке кого-то из игроков или врагов
    const occupied = [...this.playerTeam, ...this.enemyTeam].some(
      (char) => char.position === index
    );
    return !occupied; // true, если свободна
  }
}
